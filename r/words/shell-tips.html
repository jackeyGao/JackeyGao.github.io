<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="author"  content="JackeyGao">
    <meta name="description" content="JackeyGao, 一个程序员的技术分享和对生活的理解.">
    <meta name="keywords"  content="JackeyGao, JackeyGao的日记本, Python, Django, Vue.js, chinese-poetry">
    <title>终端操作(SHELL)技巧</title>
    <meta name="google-site-verification" content="xTBu05X0P9OJkoWvQWGdZimRp6nD6uqesWwTJ6v-BoA" />
    <meta name="google-site-verification" content="7Obwo8u7tT_NKgyJiirEB1qRpINEnh9BtyBa1WtiVjU" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="apple-touch-icon" sizes="180x180" href="/static/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon/favicon-16x16.png">
    <link rel="manifest" href="/static/favicon/site.webmanifest">
    <link rel="mask-icon" href="/static/favicon/safari-pinned-tab.svg" color="#286272">
    <link rel="shortcut icon" href="/static/favicon/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="/static/favicon/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="/static/global.css">
    <link rel="stylesheet" href="/static/mobile.css">
    

    
<link rel="stylesheet" href="/static/word.css">
<link rel="stylesheet" href="/static/highlight.css">
<link rel="stylesheet" href="/static/3rd/gitalk.css">

<style>
</style>

  </head>

  <body>
    <div id="canvasWrapper">
      <div id="canvas">
        <div id="toTop" onclick="topFunction();">⇪</div>

        <div id="mobileNav" class="hidden">
          <div id="avatarWrapper">
            <img class="avatar" src="/static/images/avatar.png">
          </div>
          <div id="menuNav"></div>
        </div>
        <div id="headerWrapper">
            <header>
                <div id="topNavMobile">
                    <nav id="mobileMenuLink" onclick="ToggleMenu()" class="main-nav clear">☰</nav>
                  </div>
                <div id="logo">
                  <a href='/'><img class="logo image" src="/static/images/logo.png"></a>
                </div>
                <div id="topNav">
                  <nav id="mainNavigation">
                    <ul>
                      <li>
                        <a href="/">文章</a>
                      </li>
                      <li>
                        <a href="/r/about.html">关于</a>
                      </li>
                      <li>
                        <a href="/r/links.html">链接</a>
                      </li>
                      <li>
                        <a href="#">ღ</a>
                      </li>
                    </ul>
                  </nav>
                  <nav id="secondaryNavigation">
                    <ul>
                      
                      <li>
                        <a href="/r/sets.html#个人项目">个人项目</a>
                      </li>
                      
                      <li>
                        <a href="/r/sets.html#瞎JB扯淡">瞎JB扯淡</a>
                      </li>
                      
                      <li>
                        <a href="/r/sets.html#淫诗作对">淫诗作对</a>
                      </li>
                      
                      <li>
                        <a href="/r/sets.html#好玩的Django">好玩的Django</a>
                      </li>
                      
                      <li>
                        <a href="/r/sets.html#Django小技巧">Django小技巧</a>
                      </li>
                      
                      <li>
                        <a href="/r/sets.html#随笔">随笔</a>
                      </li>
                      
                    </ul>
                  </nav>
                </div>

                <div id="avatarWrapper">
                  <img class="avatar" src="/static/images/avatar.png">
                </div>
            </header>
          </div>
        <div id="pageWrapper">
          
<div id="content" class="typo ui container">
    <div id="article">
        <h1 class="bigtitle">终端操作(SHELL)技巧</h1>
        <p class="post-date">Posted November 29, 2018</p>
        <p><figure class="hassubimage"><img src="/uploads/images/shell-tips.jpeg"></figure></p>

<p>本篇是一些小但是有用的终端操作技巧和一些快捷方式，可以让你在 linux 命令行有出奇的效率。一方面这些技巧可以让你的效率有所提高， 但有时候也会有隐患， 所以终端操作一定要注意高风险的行为， 每一步也都要小心的执行。</p>

<p>当然我相信你也有祖传的小技巧， 自己偷偷的使用， 希望你也能通过留言评论， 分享给大家。</p>
<h2 id="0.使用 Tab 键补齐.">0.使用 Tab 键补齐.</h2>
<p>如果一个命令， 或者命令参数很长， 并且命令支持补全操作， 那么通过 Tab 键可以很方便的自动补全后面的参数。 当你在命令行键入内容的时候，可以按 Tab 键来显示可能的后面需要补齐的选项, 你可以根据这些选项来进一步操作。</p>

<p>一般执行一个命令， 命令可以补齐， 参数也可以补齐，一个命令操作一般连续按下多次 Tab 键才能完成输入， 最后确保没有问题的时候回车执行。 </p>

<p>这个技巧可以让我们不需要死记硬背所有的命令和参数， 你只需要知道命令大概的名字和作用即可。</p>
<div id="code-1515039881394644397" class="code-wrapper"><div class="highlight"><pre><span></span>$ <span class="nb">cd</span> m<span class="o">[</span>按下Tab<span class="o">]</span>
my-test-directory-00001    my-test-directory-00002    my-test-directory-00003
my-test-directory-00004    main.py

$ <span class="nb">cd</span> my<span class="o">[</span>按下Tab<span class="o">]</span>
$ <span class="nb">cd</span> my-test-direction-0000<span class="o">[</span>按下Tab<span class="o">]</span>
my-test-directory-00001    my-test-directory-00002    my-test-directory-00003
my-test-directory-00004
</pre></div>
<a href="#code-1515039881394644397" id="code-1515039881394644397" class="lang-label"><\>shell</a></div><h2 id="1.回到上一个工作目录">1.回到上一个工作目录</h2>
<p>假设你要在一个目录中工作， 但是你需要到其他的目录处理一个小的问题， 处理完后你可以快速的回到工作目录中. 这是一个非常常用的技巧.</p>
<div id="code-944302953314614743" class="code-wrapper"><div class="highlight"><pre><span></span>$ <span class="nb">pwd</span>
/Users/jackeygao/Coding
$ <span class="nb">cd</span> ~/Downloads
$ <span class="nb">pwd</span>
/Users/jackeygao/Downloads
$ <span class="nb">cd</span> -
~/Coding
$ <span class="nb">pwd</span>
/Users/jackeygao/Coding
</pre></div>
<a href="#code-944302953314614743" id="code-944302953314614743" class="lang-label"><\>shell</a></div><h2 id="2.回到主目录">2.回到主目录</h2>
<p>无论你在任何位置， 你可以通过下面命令快速回到用户目录.</p>
<div id="code-3502898815473350770" class="code-wrapper"><div class="highlight"><pre><span></span><span class="nb">cd</span> ~
</pre></div>
<a href="#code-3502898815473350770" id="code-3502898815473350770" class="lang-label"><\>shell</a></div>
<p>or </p>
<div id="code5473387298025946267" class="code-wrapper"><div class="highlight"><pre><span></span><span class="nb">cd</span>
</pre></div>
<a href="#code5473387298025946267" id="code5473387298025946267" class="lang-label"><\>shell</a></div><h2 id="3.一行执行多个命令">3.一行执行多个命令</h2>
<p>多个语句可以通过&#39;;&#39;分割</p>
<div id="code-2612174126455914664" class="code-wrapper"><div class="highlight"><pre><span></span>$ <span class="nb">echo</span> Hello<span class="p">;</span> <span class="nb">echo</span> World<span class="p">;</span> <span class="nb">echo</span> <span class="s1">&#39;.&#39;</span><span class="p">;</span>
Hello
World
.
</pre></div>
<a href="#code-2612174126455914664" id="code-2612174126455914664" class="lang-label"><\>shell</a></div><h2 id="4.一行执行多个命令 (只有上一句执行成功才执行)">4.一行执行多个命令 (只有上一句执行成功才执行)</h2>
<p>比较类似于链式操作， 但需要保证上一句的结果. SHELL 语言没有好的异常停止机制， 所以你必须显式的控制语句.  和上面有区别的是， 可以通过&amp;&amp;串联多个语句， 来保证所有语句必须在上一次执行成功才能这执行. 下面例子中如果 python-devel 已经安装， echo <q>no</q>不会执行. </p>
<div id="code-7642589648960442920" class="code-wrapper"><div class="highlight"><pre><span></span>$ rpm -qa <span class="p">|</span> grep python-devel <span class="p">&amp;</span>&gt; /dev/null <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;ok&quot;</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">&quot;no&quot;</span>
ok
</pre></div>
<a href="#code-7642589648960442920" id="code-7642589648960442920" class="lang-label"><\>shell</a></div>
<p>在 shell 中， 执行成功或者成功的完成了某个命令(比如grep的匹配)返回码用0表示, 失败或者没有完成某个命令的逻辑则用非0表示. </p>

<ul>
<li>&amp;&amp; 表示上一句返回码0才会执行</li>
<li>|| 表示上一句返回码非0才会执行</li>
<li>; 无论如何都执行</li>
</ul>

<p>关于返回码, 你可以需要进一步的了解<a href="https://www.shellscript.sh/exitcodes.html">https://www.shellscript.sh/exitcodes.html</a>.</p>
<h2 id="5.搜索并执行历史命令">5.搜索并执行历史命令</h2>
<p>通过搜索历史命令， 可以很轻松的对历史命令进行复用。 一般很多 SHELL 程序都支持历史命令搜索.</p>
<div id="code421661233015848313" class="code-wrapper"><div class="highlight"><pre><span></span>Ctrl + R   然后 键入关键字
</pre></div>
<a href="#code421661233015848313" id="code421661233015848313" class="lang-label"><\>shell</a></div><div id="code1123700590818003546" class="code-wrapper"><div class="highlight"><pre><span></span>$ docker run --rm -i -p <span class="m">8001</span>:8001 -t nova python manage.py runserver <span class="m">0</span>.0.0.0:8001
bck-i-search: docker run       &lt; 在这个提示符输入关键字<span class="o">(</span>通过 Ctrl + R快捷键调出<span class="o">)</span>
</pre></div>
<a href="#code1123700590818003546" id="code1123700590818003546" class="lang-label"><\>shell</a></div><h2 id="6.解锁你的终端">6.解锁你的终端</h2>
<p>如果你不小心按到了 Ctrl + S , 那么你会得到一个『冻僵』(只是暂停(Stop)了)的终端 ， 好像和死了一样。 而 Ctrl + S 是一般保存文档的快捷键， 这在和 vim 命令编辑文件的时候经常遇到的事情， 不要慌可以通过Ctrl + Q快捷键解冻. </p>
<h2 id="7. 移动到行首或行尾">7. 移动到行首或行尾</h2>
<p>如下图， 如果我输入一个长的命令， 输入到最后在执行前我发现了问题， 需要在行首增加 sudo 。 这时我可以使用 Ctrl  + A移动光标到行首.</p>

<p><figure class="hassubimage"><img src="/uploads/images/move-to-first-and-move-to-end.jpeg"></figure></p>
<h2 id="8. 删除一个单词">8. 删除一个单词</h2>
<p>默认通过 退格键 可以删除一个字符, 但如果我的命令很长， 删除操作就会很慢。 可以通过 Esc + 退格键(Backspace) 来删除一个单词(以空格, 符号分割区分).</p>
<h2 id="9. 使用上个命令的最后参数">9. 使用上个命令的最后参数</h2>
<p>这个是很常见的场景， 比如我们创建一个目录， 一般紧接着就进到这个空目录操作了. 虽然可以补全操作， 但有一种更简单的方法，你也应该知道， 这会让你显得很酷。 就是组合快捷键[ESC + .], .号就是英文状态下的句号. 也可以通过<code>!$</code>.</p>
<div id="code5284127230630870349" class="code-wrapper"><div class="highlight"><pre><span></span>$ mkdir my-test-directory-00001
mkdir: test: File exists
$ <span class="nb">cd</span> <span class="o">[</span>按下EST + .<span class="o">]</span> my-test-directory-00001

方法二:

$ <span class="nb">cd</span> !$
$ <span class="nb">cd</span>  my-test-directory-00001
</pre></div>
<a href="#code5284127230630870349" id="code5284127230630870349" class="lang-label"><\>shell</a></div><h2 id="10. 使用上一个命令">10. 使用上一个命令</h2>
<p>和上面不同的是， 这个操作是直接使用上一个命令， 而不是最后一个参数.</p>

<p>假如我需要安装一个包, 执行完毕后发现需要 root用户才可以安装， 这时我需要在前面加sudo。 请谨慎使用这个.</p>
<div id="code-8533411411941448749" class="code-wrapper"><div class="highlight"><pre><span></span>$ yum -y install nginx
permission denied

$ sudo !!
sudo yum -y install nginx
Loaded plugins: fastestmirror
....
</pre></div>
<a href="#code-8533411411941448749" id="code-8533411411941448749" class="lang-label"><\>shell</a></div><h2 id="11.xargs">11.xargs</h2>
<p>这是一个魔法命令， 希望你去研究并学会它.</p>

<p><a href="http://man7.org/linux/man-pages/man1/xargs.1.html">main xargs</a></p>
<h2 id="12.使用 Python 替代你的 Shell.">12.使用 Python 替代你的 Shell.</h2>
<p>前面已经说到， SHELL 没有严谨的异常处理. 如果有自动脚本， 这让服务器运维增加风险属性。 小的脚本还好， 一旦脚本迭代了几个需求，臃肿复杂而且维护性极差， 甚至会非常不安全。 我推荐你使用高级语言来替代 SHELL。 推荐 Python， Ruby 等解释性语言. 大多数系统都自带了 Python, 这对我们对脚本打包提供便利.</p>

<p>以上 : )</p>

        
    </div>

    <hr>
    
    <div class="controls">
      <div class="trigger-comment" onclick=" gitalk.render('comments');">𝔔</div>
      
    </div>

    <div id="comments"></div>
</div>

        </div>
        <div id="footerWrapper">
        </div>
      </div>
    </div>
  </body>
  <script>
  window.menu = '☰'
  function ToggleMenu () {
    var mobile = document.getElementById('mobileNav');
    var menu = document.getElementById('menuNav');
    var t = document.getElementById('mobileMenuLink');
    var topNav = document.getElementById('topNav');
  
    if (mobile.className === "visible") {
      mobile.className = 'hidden'
      t.innerHTML = '☰'
      window.menu = '☰'
    } else {
      mobile.className = 'visible'
      menu.innerHTML = topNav.innerHTML;
      t.innerHTML = '⌫'
      window.menu = '⌫'
    }
  }

  window.onscroll = function() {scrollFunction()};

  function topFunction() {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
  }

  function scrollFunction() {
    var t = document.getElementById('mobileMenuLink');
    var toTop = document.getElementById('toTop');
    var m = document.getElementById('mobileNav');
    var scrollTop = m.offsetHeight > 100 ? m.offsetHeight : 800;
    if (document.body.scrollTop > scrollTop || document.documentElement.scrollTop > scrollTop) {
      t.innerHTML = '⇪'
      t.onclick = function() {topFunction()};
      toTop.className = 'visible'
    } else {
      t.innerHTML = window.menu
      t.onclick = function() {ToggleMenu()};
      toTop.className = ''
    }
  }

  </script>

  

  
<script src="/static/3rd/gitalk.min.js"></script>
<script>
  const gitalk = new Gitalk({
      clientID: '177af99888a292531873',
      clientSecret: '7c0927c7cdf0d94eed7dad0b238552c10ec6f53c',
      repo: 'JackeyGao.github.io',
      owner: 'jackeyGao',
      admin: ['jackeyGao'],
      id: 'shell-tips',      // Ensure uniqueness and length less than 50
      distractionFreeMode: false,  // Facebook-like distraction free mode
      labels: ['gitment'],
      pagerDirection: "last"
  })
  // gitalk.render('comments')
</script>

</html>